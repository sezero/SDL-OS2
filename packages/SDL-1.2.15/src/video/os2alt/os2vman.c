#ifdef USE_GRE_CALLS
// OpenWatcom's library os2386.lib does not contain entries
// Gre32Entry1..Gre32Entry10. Need os2386.lib from IBM OS/2 developer's toolkit
// for calls GreDeath() and GreResurrection().
// File %LIBHOME%\h\os2386tk.h must be automatically generated by makefile and
// should contain something like this:
//   #pragma library ("<path from LIBHOME>\lib\os2386.lib")
#include <os2386tk.h>
#endif

#include "SDL_os2alt.h"
#include "gradd.h"
#define INCL_GRE_DEVICE
#define INCL_GRE_DEVMISC
#include <pmddi.h>

static HMODULE			hmodVMan = NULLHANDLE;
static FNVMIENTRY		*pfnVMIEntry;
static ULONG			ulVRAMAddress = 0;

VOID APIENTRY _AtExit();

   
static BOOL VManInit(SDL_PrivateVideoData *pPVData)
{
  CHAR			achBuf[256];
  ULONG			ulRC;
  INITPROCOUT		sInitProcOut;

  ulRC = DosLoadModule( achBuf, sizeof(achBuf), "VMAN", &hmodVMan );
  if ( ulRC != NO_ERROR )
  {
    debug( "Could not load VMAN.DLL, rc = %u : %s", ulRC, achBuf );
    return FALSE;
  }

  ulRC = DosQueryProcAddr( hmodVMan, 0L, "VMIEntry", (PFN *)&pfnVMIEntry );
  if ( ulRC != NO_ERROR )
  {
    debug( "Could not query address of pfnVMIEntry function of VMAN.DLL, "
           "rc = %u", ulRC );
    DosFreeModule( hmodVMan );
    hmodVMan = NULLHANDLE;
    return FALSE;
  }

  sInitProcOut.ulLength = sizeof(sInitProcOut);
  ulRC = pfnVMIEntry( 0, VMI_CMD_INITPROC, NULL, &sInitProcOut );
  if ( ulRC != RC_SUCCESS )
  {
    debug( "Could not initialize VMAN for this process" );
    DosFreeModule( hmodVMan );
    hmodVMan = NULLHANDLE;
    return FALSE;
  }


  if ( pPVData == NULL )
  {
    // It only check VMan availability...
    pfnVMIEntry( 0, VMI_CMD_TERMPROC, NULL, NULL );
    return TRUE;
  }

  ulVRAMAddress = sInitProcOut.ulVRAMVirt;

  // Set routine that run when the current process ends, before PM-related
  // internal procedure.
  ulRC = DosExitList( EXLST_ADD
                     | 0x00009900, // Before Presentation Manager (0xA0 - 0xA8)
                     _AtExit );

  return TRUE;
}

static VOID VManDone(SDL_PrivateVideoData *pPVData)
{
  ULONG			ulRC;

  // For programs running in the VIO session at the function VMI_CMD_TERMPROC
  // call occurs the system to hang. We will try do not use VMI_CMD_TERMPROC
  // for VIO-programs.
  if ( !pPVData->fVIOSession && ulVRAMAddress != 0 )
  {
    debug( "Destroy VMI Entry" );
    ulRC = pfnVMIEntry( 0, VMI_CMD_TERMPROC, NULL, NULL );
    if ( ulRC != NO_ERROR )
      debug( "pfnVMIEntry(,VMI_CMD_TERMPROC,,), rc = %u", ulRC );
  }

  if ( hmodVMan != NULLHANDLE )
  {
    DosFreeModule( hmodVMan );
    hmodVMan = NULLHANDLE;
  }

  ulVRAMAddress = 0;
}

static VOID VManFreeVideoModes(SDL_PrivateVideoData *pPVData)
{
  PVIDEOMODE		pNext;
  ULONG			ulIdx;

  while( pPVData->pVideoModes != NULL )
  {
    pNext = pPVData->pVideoModes->pNext;
    SDL_free( pPVData->pVideoModes );
    pPVData->pVideoModes = pNext;
  }

  for( ulIdx = 0; ulIdx < OS2VMAN_FSMODELIST_SIZE; ulIdx++ )
    if ( pPVData->pListVideoModes[ulIdx] != NULL )
      SDL_free( pPVData->pListVideoModes );
}

static BOOL VManQueryVideoModes(SDL_PrivateVideoData *pPVData)
{
  ULONG			ulRC;
  GDDMODEINFO		sCurModeInfo;
  VMIQCI		sVmiQCI;
  CHAININFO		*pChainInfo;
  PGRADDINFO		pGraddInfo;
  GDDMODEINFO		*pModeInfo;
  ULONG			ulIdx;
  PVIDEOMODE		pVideoMode;

  SDL_Rect		**ppSDLRectList;
  ULONG			ulRectIdx;
  LONG			lPos;
  static ULONG		aModeItemBPP[OS2VMAN_FSMODELIST_SIZE] = {15,8,16,24,32};

  // Query avaible video modes from VMAN, fill pVideoModes, detect current mode

  ulRC = pfnVMIEntry( 0, VMI_CMD_QUERYCURRENTMODE, NULL, &sCurModeInfo );
  if ( ulRC != RC_SUCCESS )
  {
    SDL_SetError( "Could not query desktop video mode." );
    return FALSE;
  }

  sVmiQCI.ulLength = sizeof(VMIQCI);
  ulRC = pfnVMIEntry( 0, VMI_CMD_QUERYCHAININFO, NULL, &sVmiQCI );
  if ( ulRC != RC_SUCCESS )
  {
    SDL_SetError( "pfnVMIEntry(,VMI_CMD_QUERYCHAININFO,,), rc = %u", ulRC );
    return FALSE;
  }

  for( pChainInfo = sVmiQCI.pciHead; pChainInfo != NULL;
       pChainInfo = pChainInfo->pNextChainInfo )
  {
    for( pGraddInfo = pChainInfo->pGraddList; pGraddInfo != NULL;
         pGraddInfo = pGraddInfo->pNextGraddInfo )
    {
      pModeInfo = pGraddInfo->pModeInfo;

      for( ulIdx = 0; ulIdx < pGraddInfo->cModes; ulIdx++,
           pModeInfo = (GDDMODEINFO *)&((PCHAR)pModeInfo)[pModeInfo->ulLength] )
      {
        if ( pModeInfo->ulBpp == 16 && pModeInfo->cColors == 32768 )
          pModeInfo->ulBpp = 15;

        debug( "Mode %X %ux%u, BPP: %u (%.4s), colors: %d%s%s",
               pModeInfo->ulModeId, pModeInfo->ulHorizResolution,
               pModeInfo->ulVertResolution, pModeInfo->ulBpp,
               &pModeInfo->fccColorEncoding, pModeInfo->cColors,
               pModeInfo->ulModeId == sCurModeInfo.ulModeId ? " - CURRENT" : "",
               /*pModeInfo->ulBpp <= 8 ? " - IGNORED" : */"" );

        // if ( pModeInfo->ulBpp <= 8 )
        //   continue;

        pVideoMode = SDL_malloc( sizeof(VIDEOMODE) );
        if ( pVideoMode == NULL )
        {
          SDL_NotEnoughMemory();
          VManFreeVideoModes( pPVData );
          return FALSE;
        }

        if ( pModeInfo->ulModeId == sCurModeInfo.ulModeId )
          pPVData->pDesktopVideoMode = pVideoMode;

        pVideoMode->uiModeID         = pModeInfo->ulModeId;
        pVideoMode->sSDLRect.x       = 0;
        pVideoMode->sSDLRect.y       = 0;
        pVideoMode->sSDLRect.w       = pModeInfo->ulHorizResolution;
        pVideoMode->sSDLRect.h       = pModeInfo->ulVertResolution;
        pVideoMode->uiBPP            = pModeInfo->ulBpp;
        pVideoMode->uiScanLineSize   = pModeInfo->ulScanLineSize;
        pVideoMode->fccColorEncoding = pModeInfo->fccColorEncoding;
        pVideoMode->pNext            = pPVData->pVideoModes;
        pPVData->pVideoModes = pVideoMode;
      }
    }
  }

  if ( pPVData->pDesktopVideoMode == NULL )
  {
    SDL_SetError( "Current video mode not found" );
    VManFreeVideoModes( pPVData );
    return FALSE;
  }

  // Sort video modes, fill pListVideoModes - it will be returned to SDL

  for( ulIdx = 0; ulIdx < OS2VMAN_FSMODELIST_SIZE; ulIdx++ )
  {
    ppSDLRectList = pPVData->pListVideoModes[ulIdx];

    for( pVideoMode = pPVData->pVideoModes; pVideoMode != NULL;
         pVideoMode = pVideoMode->pNext )
    {
      if ( pVideoMode->uiBPP != aModeItemBPP[ulIdx] )
        continue;

      if ( ppSDLRectList == NULL )
      {
        // First record in list
        ppSDLRectList = SDL_malloc( 2 * sizeof(SDL_Rect*) );
        if ( ppSDLRectList == NULL )
          continue;

        ppSDLRectList[0] = &pVideoMode->sSDLRect;
        ppSDLRectList[1] = NULL;
        pPVData->pListVideoModes[ulIdx] = ppSDLRectList;
        continue;
      }

      // Search position in sorted list, count number of items
      lPos = -1;
      for( ulRectIdx = 0; ppSDLRectList[ulRectIdx] != NULL; ulRectIdx++ )
      {
        if ( lPos != -1 ) // Position found - continue calc number of items
          continue;

        if ( ( ppSDLRectList[ulRectIdx]->w * ppSDLRectList[ulRectIdx]->h ) <
             ( pVideoMode->sSDLRect.w * pVideoMode->sSDLRect.h ) )
          lPos = ulRectIdx;
      }

      if ( lPos == -1 )
        lPos = ulRectIdx; // Position not found, get position of NULL
      ulRectIdx++;

      // Insert new item
      ppSDLRectList = SDL_realloc( ppSDLRectList,
                                   ( ulRectIdx + 1 ) * sizeof(SDL_Rect*) );
      if ( ppSDLRectList == NULL )
        continue;
      pPVData->pListVideoModes[ulIdx] = ppSDLRectList;
      SDL_memmove( &ppSDLRectList[lPos + 1], &ppSDLRectList[lPos],
                   ( ulRectIdx - lPos ) * sizeof(SDL_Rect*) );
      ppSDLRectList[lPos] = &pVideoMode->sSDLRect;
    }
  }

#ifdef DEBUG_BUILD
  // Debug. Show sorted lists
  for( ulIdx = 0; ulIdx < OS2VMAN_FSMODELIST_SIZE; ulIdx++ )
  {
    ppSDLRectList = pPVData->pListVideoModes[ulIdx];
    if ( ppSDLRectList == NULL )
      continue;
    debug( "Modes list #%u for %u BPP:", ulIdx, aModeItemBPP[ulIdx] );
    for( ulRectIdx = 0; ppSDLRectList[ulRectIdx] != NULL; ulRectIdx++ )
      debug( "  %u x %u", ppSDLRectList[ulRectIdx]->w,
                          ppSDLRectList[ulRectIdx]->h );
  }
#endif
  return TRUE;
}

static VOID VManUpdateRects(SDL_PrivateVideoData *pPVData,
                             SDL_Rect *pSDLRectWin, // window rectangle on screen
                             SDL_Rect *pSDLRectFrame, // surface rectangle on window
                             int cRects, // number of record to update
                             SDL_Rect *pRects) // records to update
{
  BMAPINFO		bmiSrc;
  BMAPINFO		bmiDst;
  HWREQIN		sHWReqIn;
  BITBLTINFO		sBitbltInfo = { 0 };
  PRECTL		prectlScreenUpdate;
  RECTL			rclItem;
  RECTL			rclSrcBounds;
  RECTL			rclDstBounds;
  PPOINTL		pptlSrcOrg;
  PBLTRECT		pbrDst;
  ULONG			ulIdx;
  PVIDEOMODE		pVideoMode;

  bmiSrc.ulLength = sizeof(BMAPINFO);
  bmiSrc.ulType = BMAP_MEMORY;
  bmiSrc.ulWidth = pPVData->pSDLSurface->w;
  bmiSrc.ulHeight = pPVData->pSDLSurface->h;
  bmiSrc.ulBpp = pPVData->pSDLSurface->format->BitsPerPixel;
  bmiSrc.ulBytesPerLine = pPVData->pSDLSurface->pitch;
  bmiSrc.pBits = (PBYTE)pPVData->pSDLSurface->pixels;

  pVideoMode = pPVData->fFullscreen ?
                 pPVData->pFSVideoMode : pPVData->pDesktopVideoMode;
  bmiDst.ulLength = sizeof(BMAPINFO);
  bmiDst.ulType = BMAP_VRAM;
  bmiDst.pBits = (PBYTE)ulVRAMAddress;
  bmiDst.ulWidth = pVideoMode->sSDLRect.w;
  bmiDst.ulHeight = pVideoMode->sSDLRect.h;
  bmiDst.ulBpp = pVideoMode->uiBPP;
  bmiDst.ulBytesPerLine = pVideoMode->uiScanLineSize;

  // Fill lists: source coordinates (pptlSrcOrg), detination screen rectangles
  // (pbrDst), screen update rectangles (prectlScreenUpdate), calc source bound
  // (rclSrcBounds).

  pptlSrcOrg = SDL_malloc( cRects * sizeof(POINTL) );
  if ( pptlSrcOrg == NULL )
  {
    SDL_NotEnoughMemory();
    return;
  }
  pbrDst = SDL_malloc( cRects * sizeof(BLTRECT) );
  if ( pptlSrcOrg == NULL )
  {
    SDL_NotEnoughMemory();
    SDL_free( pptlSrcOrg );
    return;
  }
  prectlScreenUpdate = SDL_malloc( cRects * sizeof(RECTL) );
  if ( pptlSrcOrg == NULL )
  {
    SDL_NotEnoughMemory();
    SDL_free( pbrDst );
    SDL_free( pptlSrcOrg );
    return;
  }
  WinSetRectEmpty( pPVData->hab, &rclSrcBounds );

  for( ulIdx = 0; ulIdx < cRects; ulIdx++, pRects++ )
  {
    pptlSrcOrg[ulIdx].x = pRects->x;
    pptlSrcOrg[ulIdx].y = pRects->y;
    pbrDst[ulIdx].ulXOrg = pRects->x + pSDLRectWin->x + pSDLRectFrame->x;
    pbrDst[ulIdx].ulYOrg = pRects->y + pSDLRectWin->y + pSDLRectFrame->y;
    pbrDst[ulIdx].ulXExt = pRects->w;
    pbrDst[ulIdx].ulYExt = pRects->h;

    rclItem.xLeft = pRects->x;
    rclItem.xRight = pRects->x + pRects->w - 1;
    rclItem.yTop = bmiSrc.ulHeight - pRects->y;
    rclItem.yBottom = rclItem.yTop - pRects->h + 1;
    WinUnionRect( pPVData->hab, &rclSrcBounds, &rclSrcBounds, &rclItem );

    WinOffsetRect( pPVData->hab, &rclItem, pSDLRectWin->x + pSDLRectFrame->x,
                   bmiDst.ulHeight - (pSDLRectWin->y + pSDLRectFrame->y) );
    WinCopyRect( pPVData->hab, &prectlScreenUpdate[ulIdx], &rclItem );
  }

  if ( WinIsRectEmpty( pPVData->hab, &rclSrcBounds ) )
    return;

  // Detination bounding rectangle
  WinCopyRect( pPVData->hab, &rclDstBounds, &rclSrcBounds );
  WinOffsetRect( pPVData->hab, &rclDstBounds, pSDLRectWin->x + pSDLRectFrame->x,
                 bmiDst.ulHeight - (pSDLRectWin->y + pSDLRectFrame->y) );

  // Request HW
  sHWReqIn.ulLength = sizeof(HWREQIN);
  sHWReqIn.ulFlags = REQUEST_HW;
  sHWReqIn.cScrChangeRects = cRects;
  sHWReqIn.arectlScreen = prectlScreenUpdate;
  if ( pfnVMIEntry( 0, VMI_CMD_REQUESTHW, &sHWReqIn, NULL ) != RC_SUCCESS )
  {
    debug( "pfnVMIEntry(,VMI_CMD_REQUESTHW,,) failed" );
  }
  else
  {
    sBitbltInfo.ulLength = sizeof(BITBLTINFO);
    sBitbltInfo.ulBltFlags = BF_DEFAULT_STATE | BF_ROP_INCL_SRC | BF_PAT_HOLLOW;
    sBitbltInfo.cBlits = cRects;
    sBitbltInfo.ulROP = ROP_SRCCOPY;
    sBitbltInfo.pSrcBmapInfo = &bmiSrc;
    sBitbltInfo.pDstBmapInfo = &bmiDst;
    sBitbltInfo.prclSrcBounds = &rclSrcBounds;
    sBitbltInfo.prclDstBounds = &rclDstBounds;
    sBitbltInfo.aptlSrcOrg = pptlSrcOrg;
    sBitbltInfo.abrDst = pbrDst;

    if ( pfnVMIEntry( 0, VMI_CMD_BITBLT, &sBitbltInfo, NULL ) != RC_SUCCESS )
    {
      debug( "pfnVMIEntry(,VMI_CMD_BITBLT,,) failed" );
    }
    else
    {
      // Release HW
      sHWReqIn.ulFlags = 0;
      if ( pfnVMIEntry( 0, VMI_CMD_REQUESTHW, &sHWReqIn, NULL ) != RC_SUCCESS )
        debug( "pfnVMIEntry(,VMI_CMD_REQUESTHW,,) failed" );
    }
  }

  SDL_free( prectlScreenUpdate );
  SDL_free( pptlSrcOrg );
  SDL_free( pbrDst );
}

// _VManClearFS() clear (fill black color) screen in fullscreen mode
static VOID _VManClearFS(SDL_PrivateVideoData *pPVData)
{
  LINEINFO		sLineInfo = { 0 };
  BMAPINFO		bmiDst;
  LINEPACK		sLine = { 0 };
  RECTL			rclBounds;
  HWREQIN		sHWReqIn;
  ULONG			ulIdx;

  bmiDst.ulLength = sizeof(BMAPINFO);
  bmiDst.ulType = BMAP_VRAM;
  bmiDst.pBits = (PBYTE)ulVRAMAddress;
  bmiDst.ulWidth = pPVData->pFSVideoMode->sSDLRect.w;
  bmiDst.ulHeight = pPVData->pFSVideoMode->sSDLRect.h;
  bmiDst.ulBpp = pPVData->pFSVideoMode->uiBPP;
  bmiDst.ulBytesPerLine = pPVData->pFSVideoMode->uiScanLineSize;

  rclBounds.xLeft = 0;
  rclBounds.yBottom = 0;
  rclBounds.xRight = bmiDst.ulWidth;
  rclBounds.yTop = bmiDst.ulHeight;

  sHWReqIn.ulLength = sizeof(HWREQIN);
  sHWReqIn.ulFlags = REQUEST_HW;
  sHWReqIn.cScrChangeRects = 1;
  sHWReqIn.arectlScreen = &rclBounds;

  if ( pfnVMIEntry( 0, VMI_CMD_REQUESTHW, &sHWReqIn, NULL ) != RC_SUCCESS )
  {
    debug( "pfnVMIEntry(,VMI_CMD_REQUESTHW,,) failed" );
    return;
  }

  sLine.ulFlags = LINE_DIR_Y_POSITIVE | LINE_DIR_X_POSITIVE |
                  LINE_HORIZONTAL | LINE_DO_FIRST_PEL | LINE_DO_LAST_PEL;
  sLine.plpkNext = NULL;
  sLine.ptlClipEnd.x = rclBounds.xRight;
  sLine.ptlEnd.x = rclBounds.xRight;

  sLineInfo.ulLength = sizeof(LINEINFO);
  sLineInfo.ulType = LINE_SOLID;
  sLineInfo.cLines = 1;
  sLineInfo.pDstBmapInfo = &bmiDst;
  sLineInfo.alpkLinePack = &sLine;
  sLineInfo.prclBounds = &rclBounds;

  for( ulIdx = 0; ulIdx < rclBounds.yTop; ulIdx++ )
  {
    sLine.ptlClipStart.y = ulIdx;
    sLine.ptlClipEnd.y   = ulIdx;
    sLine.ptlStart.y     = ulIdx;
    sLine.ptlEnd.y       = ulIdx;
    if ( pfnVMIEntry( 0, VMI_CMD_LINE, &sLineInfo, NULL ) != RC_SUCCESS )
    {
      debug( "pfnVMIEntry(,VMI_CMD_LINE,,) failed" );
      break;
    }
  }

  sHWReqIn.ulFlags = 0;
  if ( pfnVMIEntry( 0, VMI_CMD_REQUESTHW, &sHWReqIn, NULL ) != RC_SUCCESS )
    debug( "pfnVMIEntry(,VMI_CMD_REQUESTHW,,) failed" );
}

static BOOL VManSetPalette(SDL_PrivateVideoData *pPVData, ULONG ulStart,
                            ULONG cColors, SDL_Color *pColors)
{
  HWPALETTEINFO		sPalInfo;
  ULONG			ulIdx;
  ULONG			ulRC;

  if ( cColors == 0 )
    return TRUE;

  if ( ulStart >= 256 )
    return FALSE;

  sPalInfo.ulLength = sizeof(HWPALETTEINFO);
  sPalInfo.fFlags = PALETTE_SET;
  sPalInfo.ulStartIndex = ulStart;

  if ( (ulStart + cColors) >= 256 )
    sPalInfo.ulNumEntries = 256 - ulStart;
  else
    sPalInfo.ulNumEntries = cColors;

  sPalInfo.pRGBs = SDL_malloc( sPalInfo.ulNumEntries * sizeof(RGB2) );
  if ( sPalInfo.pRGBs == NULL )
  {
    SDL_NotEnoughMemory();
    return FALSE;
  }

  for( ulIdx = 0; ulIdx < sPalInfo.ulNumEntries; ulIdx++, pColors++ )
  {
    sPalInfo.pRGBs[ulIdx].bRed      = pColors->r;
    sPalInfo.pRGBs[ulIdx].bGreen    = pColors->g;
    sPalInfo.pRGBs[ulIdx].bBlue     = pColors->b;
    sPalInfo.pRGBs[ulIdx].fcOptions = 0;
  }

  ulRC = pfnVMIEntry( 0, VMI_CMD_PALETTE, &sPalInfo, NULL );
  if ( ulRC != RC_SUCCESS )
  {
    debug( "pfnVMIEntry(,VMI_CMD_PALETTE,,), rc = %u", ulRC );
    cColors = 0;
  }

  SDL_free( sPalInfo.pRGBs);
  return cColors == sPalInfo.ulNumEntries;
}

static HWND GetDesktopHWND()
{
  HAB		hab;
  HWND		hwnd;
 
  hab = WinQueryAnchorBlock(HWND_DESKTOP);
  if ( hab == NULLHANDLE )
  {
    debug( "WinQueryAnchorBlock failed.");
    return FALSE;
  }
 
  hwnd = WinQueryDesktopWindow( hab, 0 );
  if ( hwnd == NULLHANDLE )
  {
    debug( "WinQueryDesktopWindow failed." );
    return FALSE;
  }
 
  return hwnd;
}

static VOID VManSetFullscreen(SDL_PrivateVideoData *pPVData,
                              PVIDEOMODE pFSVideoMode)
{
  static ULONG		ulDesktopModeId = ((ULONG)(-1)); // -1 - in desktop
  HWSHOWPTRIN		hwspi;
  ULONG			ulRC;
  BOOL			fInFullscreen = ulDesktopModeId != ((ULONG)(-1));
  BOOL			fGoToFullscreen = pFSVideoMode != NULL;

  if ( fInFullscreen == fGoToFullscreen )
  {
    debug( "Already in %s", fInFullscreen ? "fullscreen" : "desktop" );
    return;
  }
  debug( "Switch to %s", fGoToFullscreen ? "fullscreen" : "desktop" );

  ulRC = DosSetPriority( PRTYS_PROCESS, PRTYC_FOREGROUNDSERVER, PRTYD_MAXIMUM,
                         0 );
  if ( ulRC != NO_ERROR )
    debug( "#1 DosSetPriority(), rc = %u" );

  hwspi.ulLength = sizeof(HWSHOWPTRIN);

  if ( fGoToFullscreen )
  {
    GDDMODEINFO		sCurModeInfo;

//    debug( "Video mode id: 0x%X", pFSVideoMode->uiModeID );

    ulRC = pfnVMIEntry( 0, VMI_CMD_QUERYCURRENTMODE, NULL, &sCurModeInfo );
    if ( ulRC != RC_SUCCESS )
    {
      debug( "Could not query desktop video mode." );
    }
    else
    {
      ulDesktopModeId = sCurModeInfo.ulModeId; // Remember desktop mode id

      ulRC = DosEnterCritSec();
      if ( ulRC != NO_ERROR )
        debug( "DosEnterCritSec(), rc = %u" );

      hwspi.fShow = FALSE;
      pfnVMIEntry( 0, VMI_CMD_SHOWPTR, &hwspi, NULL );
#ifdef __USE_GRE_CALLS_
      // Tell the GRE that PM will die
      GreDeath( GetDesktopHWND() );
#endif
      pfnVMIEntry( 0, VMI_CMD_SETMODE, &pFSVideoMode->uiModeID, NULL );
      if ( pPVData != NULL && pPVData->pSDLSurface != NULL )
      {
        _VManClearFS( pPVData );
        if ( pPVData->pSDLSurface != NULL &&
             pPVData->pSDLSurface->format->palette != NULL )
          VManSetPalette( pPVData, 0,
            pPVData->pSDLSurface->format->palette->ncolors,
            pPVData->pSDLSurface->format->palette->colors );
      }

      ulRC = DosExitCritSec();
      if ( ulRC != NO_ERROR )
        debug( "DosExitCritSec(), rc = %u" );
    }
  }
  else
  {
    ulRC = DosEnterCritSec();
    if ( ulRC != NO_ERROR )
      debug( "DosEnterCritSec(), rc = %u" );

    pfnVMIEntry( 0, VMI_CMD_SETMODE, &ulDesktopModeId, NULL );
#ifdef USE_GRE_CALLS
    // Tell GRE that PM can come back
    GreResurrection( GetDesktopHWND(), 0, NULL );
#endif
    // Show mouse pointer
    hwspi.fShow = TRUE;
    pfnVMIEntry( 0, VMI_CMD_SHOWPTR, &hwspi, NULL );

    ulRC = DosExitCritSec();
    if ( ulRC != NO_ERROR )
      debug( "DosExitCritSec(), rc = %u" );

    ulDesktopModeId = ((ULONG)(-1)); // We are in desktop now
  }

  ulRC = DosSetPriority( PRTYS_PROCESS, PRTYC_REGULAR, 0, 0 );
  if ( ulRC != NO_ERROR )
    debug( "#2 DosSetPriority(), rc = %u" );

  debug( "Done" );
}


VOID APIENTRY _AtExit()
{
  ULONG		ulRC;

  // Destroy VMI entry if it has been initialised and VManDone() wasn't called.
  if ( ulVRAMAddress != 0 )
  {
    debug( "It seems that VManDone() is not called" );
    // We must be sure that switched to the desktop before end of the program.
    VManSetFullscreen( NULL, NULL );
    // Update desktop.
    WinInvalidateRect( GetDesktopHWND(), NULL, TRUE );
  }

  ulRC = DosExitList( EXLST_EXIT, (PFNEXITLIST)NULL );
  if ( ulRC != NO_ERROR )
    debug( "DosExitList(), rc = %u", ulRC );
}


VIDEOSYS	sVSVMan =
{
  FALSE,
  VManInit,
  VManDone,
  VManQueryVideoModes,
  VManFreeVideoModes,
  VManUpdateRects,
  VManSetFullscreen,
  VManSetPalette,
  NULL,
  NULL,
  NULL
};
